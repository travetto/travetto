import * as path from 'path';
import { Package, PathUtil, ExecUtil, EnvUtil } from '@travetto/boot';
import { CompileBinUtil } from '@travetto/compiler/bin/lib';

import * as n from '../../src/nodes';
import { AllTypeMap } from '../../src/node-types';
import type { DocumentContext, Renderer } from '../../src/render/types';

const GIT_BRANCH = ExecUtil.execSync('git', ['status', '-b', '-s', '.']).split(/\n/)[0].split('...')[0].split(' ')[1].trim();

export class DocBinUtil {
  /**
   * Initialize for doc gen
   */
  static async init() {
    process.env.TRV_SRC_LOCAL = 'doc';
    process.env.TRV_RESOURCES = 'doc/resources';

    await CompileBinUtil.compile();

    process.env.TRV_DEBUG = '0';
    process.env.TRV_LOG_PLAIN = '1';

    const { PhaseManager } = await import('@travetto/base');
    await PhaseManager.run('init');
  }

  /**
   * Retrieve the doc renderer
   * @param fmt
   */
  static async getRenderer(fmt: string) {
    fmt = fmt.replace(/^[.]/, ''); // Strip leading .
    const { Html } = await import('../../src/render/html');
    const { Markdown } = await import('../../src/render/markdown');
    const renderers = { [Html.ext]: Html, [Markdown.ext]: Markdown };
    const renderer = renderers[fmt];
    if (!renderer) {
      console.error('Format unknown', { fmt });
      process.exit(1);
    }
    return renderer;
  }

  /**
   * Generate the text
   * @param renderer
   */
  static async generate(file: string, renderer: Renderer) {
    file = PathUtil.resolveUnix(file);

    // Get repo information
    const gitRepo = (Package.repository?.url ?? '').split(/[.]git$/)[0];
    const gitRoot = `${gitRepo}/tree/${EnvUtil.get('TRV_DOC_BRANCH', GIT_BRANCH)}`;

    // General info
    const module = this.getPackageName();

    const preamble = `<!-- This file was generated by the framweork and should not be modified directly -->
<!-- Please modify ${file.replace(/.*travetto\//, `${gitRoot}/`)} and execute "npm run docs" to rebuild -->`;

    const doc: DocumentContext = await import(file);
    // Build content
    const toc = n.Ordered(
      ...(doc.text as AllTypeMap['Group']).nodes
        .filter(x => x._type === 'section')
        .map(x => {
          const { title } = x as AllTypeMap['Section'];
          return n.Anchor(title, title);
        })
    );
    const content = renderer.render(doc.text, { toc, gitRoot, module }).trim();

    const output = doc.assemble?.[renderer.ext]?.(content) ?? renderer.assemble?.(content) ?? content;
    return `${preamble}\n${output.replace(/\n{3,100}/msg, '\n\n').trim()}\n`;
  }

  static getPackageName() {
    return path.basename(PathUtil.cwd);
  }

  /**
   * Get the output location
   * @param output
   */
  static async getOutputLoc(output: string) {
    const root = PathUtil.resolveUnix(output);
    const name = this.getPackageName();
    return root.replace(/%MOD/g, name);
  }

  /**
   * Watch a file
   * @param file
   * @param cb
   */
  static async watchFile(file: string, cb: (ev: unknown) => void) {
    const { Watcher } = await import('@travetto/watch');
    const { Compiler } = await import('@travetto/compiler');

    new Watcher(__dirname, { interval: 250, exclude: { testDir: () => false, testFile: f => f === file } })
      .on('all', e => {
        Compiler.unload(PathUtil.resolveUnix(file));
        cb(e);
      });
    await new Promise(r => setTimeout(r, 1000 * 60 * 60 * 24));
  }
}