<!-- This file was generated by @travetto/doc and should not be modified directly -->
<!-- Please modify https://github.com/travetto/travetto/tree/main/module/worker/doc.ts and execute "npx trv doc" to rebuild -->
# Worker
## Process management utilities, with a focus on inter-process communication

**Install: @travetto/worker**
```bash
npm install @travetto/worker
```

This module provides the necessary primitives for handling dependent workers.  A worker can be an individual actor or could be a pool of workers. Node provides ipc (inter-process communication) functionality out of the box. This module builds upon that by providing enhanced event management, richer process management, as well as constructs for orchestrating a conversation between two processes.

## Execution Pools
With respect to managing multiple executions, [WorkPool](https://github.com/travetto/travetto/tree/main/module/worker/src/pool.ts#L23) is provided to allow for concurrent operation, and processing of jobs concurrently.  To manage the flow of jobs, there are various [WorkSet](https://github.com/travetto/travetto/tree/main/module/worker/src/input/types.ts#L4) implementation that allow for a wide range of use cases.

The only provided [WorkSet](https://github.com/travetto/travetto/tree/main/module/worker/src/input/types.ts#L4) is the [IterableWorkSet](https://github.com/travetto/travetto/tree/main/module/worker/src/input/iterable.ts#L11) which supports all `Iterable` and `Iterator` sources.  Additionally, the module provides [ManualAsyncIterator](https://github.com/travetto/travetto/tree/main/module/worker/src/input/async-iterator.ts#L6) which allows for manual control of iteration, which is useful for event driven work loads.

Below is a pool that will convert images on demand, while queuing as needed.

**Code: Image processing queue, with a fixed batch/pool size**
```typescript
import { ExecUtil, ExecutionState } from '@travetto/boot';
import { Worker, WorkPool, IterableWorkSet, ManualAsyncIterator } from '@travetto/worker';

class ImageProcessor implements Worker<string> {
  active = false;
  proc: ExecutionState;

  get id(): number | undefined {
    return this.proc.process.pid;
  }

  async destroy(): Promise<void> {
    this.proc.process.kill();
  }

  async execute(path: string): Promise<void> {
    this.active = true;
    try {
      this.proc = ExecUtil.spawn('convert images', [path]);
      await this.proc;
    } catch {
      // Do nothing
    }
    this.active = false;
  }
}

export class ImageCompressor extends WorkPool<string, ImageProcessor> {

  pendingImages = new ManualAsyncIterator<string>();

  constructor() {
    super(async () => new ImageProcessor());
  }

  begin(): void {
    this.process(new IterableWorkSet(this.pendingImages));
  }

  convert(...images: string[]): void {
    this.pendingImages.add(images);
  }
}
```

Once a pool is constructed, it can be shutdown by calling the `.shutdown()` method, and awaiting the result.

## IPC Support

Within the `comm` package, there is support for two primary communication elements: [ChildCommChannel](https://github.com/travetto/travetto/tree/main/module/worker/src/comm/child.ts#L6) and [ParentCommChannel](https://github.com/travetto/travetto/tree/main/module/worker/src/comm/parent.ts#L11).  Usually [ParentCommChannel](https://github.com/travetto/travetto/tree/main/module/worker/src/comm/parent.ts#L11) indicates it is the owner of the sub process.  [ChildCommChannel](https://github.com/travetto/travetto/tree/main/module/worker/src/comm/child.ts#L6) indicates that it has been created/spawned/forked by the parent and will communicate back to it's parent.  This generally means that a [ParentCommChannel](https://github.com/travetto/travetto/tree/main/module/worker/src/comm/parent.ts#L11) can be destroyed (i.e. killing the subprocess) where a [ChildCommChannel](https://github.com/travetto/travetto/tree/main/module/worker/src/comm/child.ts#L6) can only exit the process, but the channel cannot be destroyed.

### IPC as a Worker
A common pattern is to want to model a sub process as a worker, to be a valid candidate in a [WorkPool](https://github.com/travetto/travetto/tree/main/module/worker/src/pool.ts#L23).  The [WorkUtil](https://github.com/travetto/travetto/tree/main/module/worker/src/util.ts#L14) class provides a utility to facilitate this desire.

**Code: Spawned Worker**
```typescript
import { ExecutionState } from '@travetto/boot';

import { ParentCommChannel } from './comm/parent';
import { Worker } from './pool';

type Simple<V> = (ch: ParentCommChannel<V>) => Promise<unknown | void>;
type Param<V, X> = (ch: ParentCommChannel<V>, input: X) => Promise<unknown | void>;

const empty = async (): Promise<void> => { };

/**
 * Spawned worker
 */
export class WorkUtil {
  /**
   * Create a process channel worker from a given spawn config
   */
  static spawnedWorker<V, X>(
    worker: () => ExecutionState,
    init: Simple<V>,
    execute: Param<V, X>,
    destroy: Simple<V> = empty): Worker<X> {
    const channel = new ParentCommChannel<V>(worker());
    return {
      get id(): number | undefined { return channel.id; },
      get active(): boolean { return channel.active; },
      init: () => init(channel),
      execute: inp => execute(channel, inp),
      async destroy(): Promise<void> {
        await destroy(channel);
        await channel.destroy();
      },
    };
  }
}
```

When creating your work, via process spawning, you will need to provide the script (and any other features you would like in `SpawnConfig`).   Additionally you must, at a minimum, provide functionality to run whenever an input element is up for grabs in the input source.  This method will be provided the communication channel ([ParentCommChannel](https://github.com/travetto/travetto/tree/main/module/worker/src/comm/parent.ts#L11)) and the input value.  A simple example could look like:

**Code: Spawning Pool**
```typescript
import { WorkPool, WorkUtil, IterableWorkSet } from '@travetto/worker';
import { ExecUtil, PathUtil } from '@travetto/boot';

export async function main(): Promise<void> {
  const pool = new WorkPool(() =>
    WorkUtil.spawnedWorker<{ data: string }, string>(
      () => ExecUtil.forkMain(PathUtil.resolveUnix(__dirname, 'spawned.ts')),
      ch => ch.once('ready'), // Wait for child to indicate it is ready
      async (channel, inp) => {
        const res = channel.once('response'); //  Register response listener
        channel.send('request', { data: inp }); // Send request

        const { data } = await res; // Get answer
        console.log('Request complete', { input: inp, output: data });

        if (!(inp + inp === data)) {
          // Ensure the answer is double the input
          throw new Error('Did not get the double');
        }
      }
    )
  );

  await pool.process(new IterableWorkSet([1, 2, 3, 4, 5])).then(x => pool.shutdown());
}
```

**Code: Spawned Worker**
```typescript
import { ChildCommChannel } from '@travetto/worker';

export async function main(): Promise<void> {
  const exec = new ChildCommChannel<{ data: string }>();

  exec.on('request', data =>
    exec.send('response', { data: (data.data + data.data) })); // When data is received, return double

  exec.send('ready'); // Indicate the child is ready to receive requests

  const heartbeat = (): void => { setTimeout(heartbeat, 5000); }; // Keep-alive
  heartbeat();
}
```

**Terminal: Output**
```bash
$ node @travetto/base/bin/main ./doc/spawner.ts 

Request complete { input: 1, output: 2 }
Request complete { input: 2, output: 4 }
Request complete { input: 3, output: 6 }
Request complete { input: 4, output: 8 }
Request complete { input: 5, output: 10 }
```
