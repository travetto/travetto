<!-- This file was generated by the framweork and should not be modified directly -->
<!-- Please modify https://github.com/travetto/travetto/tree/master/module/rest-session/doc.ts and execute "npm run docs" to rebuild -->
# REST Session
## Session provider for the travetto rest module.

**Install: @travetto/rest-session**
```bash
npm install @travetto/rest-session
```

This is a module that adds session support to the [RESTful API](https://github.com/travetto/travetto/tree/master/module/rest#readme "Declarative api for RESTful APIs with support for the dependency injection module.") framework.  Sessions are represented as:

**Code: Session Structure**
```typescript
export class Session<T extends SessionData = SessionData>  {
  /**
   * The expiry time when the session was loaded
   */
  /**
   * The hash of the session at load
   */
  /**
   * The session identifer
   */
  readonly id: string;
  /**
   * Session max age in ms
   */
  readonly maxAge?: number;
  /**
   * Session signature
   */
  readonly signature?: string;
  /**
   * Session initial issue timestamp
   */
  readonly issuedAt: Date;
  /**
   * Expires at time
   */
  expiresAt: Date | undefined;
  /**
   * What action should be taken against the session
   */
  action?: 'create' | 'destroy' | 'modify';
  /**
   * The session data
   */
  data: T | undefined;
  /**
   * Create a new Session object given a partial version of itself
   */
  constructor(data: Partial<Session>) ;
  /**
   * Get session value
   */
  getValue<V>(key: string): V | undefined ;
  /**
   * Set session value
   */
  setValue<V>(key: string, value: V): void ;
  /**
   * Determine if session has changed
   */
  isChanged() ;
  /**
   * Determine if the expiry time has changed
   */
  isTimeChanged() ;
  /**
   * See if the session is nearly expired
   */
  isAlmostExpired() ;
  /**
   * See if the session is truly expired
   */
  isExpired() ;
  /**
   * Refresh the session expiration time
   */
  refresh() ;
  /**
   * Mark the session for destruction, delete the data
   */
  destroy() ;
  /**
   * Serialize the session
   */
  toJSON() ;
}
```

A session allows for defining the expiration time, what state the session should be in, as well as the payload (session data).  The session and session data are accessible via the [@Context](https://github.com/travetto/travetto/tree/master/module/rest/src/decorator/param.ts#L46) parameter as [Session](https://github.com/travetto/travetto/tree/master/module/rest-session/src/types.ts#L16) and [SessionData](https://github.com/travetto/travetto/tree/master/module/rest-session/src/types.ts#L7) respectively.  Iit can also be accessed via the [TravettoRequest](https://github.com/travetto/travetto/tree/master/module/rest-session/src/types.d.ts#L8) as a session property.

**Code: Sample Session Usage**
```typescript
import { Controller, Put, Get, Context } from '@travetto/rest';
import { SessionData, Session } from '@travetto/rest-session';

@Controller('/session')
export class SessionRoutes {

  @Put('/info')
  async storeInfo(@Context() data: SessionData) {
    data.age = 20;
    data.name = 'Roger'; // Setting data
  }

  @Get('/logout')
  async logout(@Context() session: Session) {
    await session.destroy();
  }

  @Get('/info/age')
  async getInfo(@Context() data: SessionData) {
    return data.age;
  }
}
```

This usage should be comparable to [express](https://expressjs.com), [koa](https://koajs.com/) and mostly every other framework.

## Configuration

Session mechanics are defined by the underlying provider.

### Building a Provider

Provider are pieces that enable you manage the session state, including interaction with the request/response. This allows for sessions to be read/written to cookies, headers, url parameters, etc. Additionally, this allows for persisting session data as needed. The structure for the provider is fairly straightforward:

**Code: Provider structure**
```typescript
/home/tim/Code/travetto/module/rest-session/src/provider/types.ts
```

The provider will `encode` the session into the response.  The `decode` operation will then read the session from the request and reconstruct a fully defined [Session](https://github.com/travetto/travetto/tree/master/module/rest-session/src/types.ts#L16) object.  This allows for storing the session data externally or internal to the app.

**Code: Stateless Session Provider**
```typescript
import { Request, Response } from '@travetto/rest';
import { Inject, Injectable } from '@travetto/di';
import { AppManifest } from '@travetto/base';
import { ValueAccessor } from '@travetto/rest/src/internal/accessor';

import { SessionProvider } from './types';
import { Session } from '../types';
import { SessionConfig } from '../config';

/**
 * Allows for transparent session behavior, sending the full session in the headers.
 *
 * Signed cookies provide tampering protection, where as every other avenue
 */
@Injectable()
export class StatelessSessionProvider implements SessionProvider {

  @Inject()
  config: SessionConfig;

  accessor: ValueAccessor;

  postConstruct() {
    if (this.config.sign === false && AppManifest.prod) {
      console.error('Stateless support relies on full disclosure of state information.');
      console.error('By not signing the state, the user has full ability to override the state remotely');
    }
    this.accessor = new ValueAccessor(this.config.keyName, this.config.transport);
  }

  async sessionToText(session: Session): Promise<string> {
    return Buffer.from(JSON.stringify(session.toJSON())).toString('base64');
  }

  async textToSession(text: string): Promise<Session> {
    const parsed = JSON.parse(Buffer.from(text, 'base64').toString('utf8'));

    if (parsed.expiresAt) {
      parsed.expiresAt = new Date(parsed.expiresAt);
    }
    if (parsed.issuedAt) {
      parsed.issuedAt = new Date(parsed.issuedAt);
    }

    return new Session(parsed);
  }

  async encode(req: Request, res: Response, session: Session | null): Promise<void> {
    if (session) {
      this.accessor.writeValue(res, await this.sessionToText(session), { expires: session?.expiresAt });
    } else {
      this.accessor.writeValue(res, null, { expires: new Date() });
    }
    return;
  }

  async decode(req: Request): Promise<Session | undefined> {
    const payload = this.accessor.readValue(req);
    if (payload) {
      return await this.textToSession(payload);
    }
  }
}
```

**Code: Model Session Provider**
```typescript
import { Request, Response } from '@travetto/rest';
import { Inject, Injectable } from '@travetto/di';
import { ExpiresAt, Model, ModelCrudSupport } from '@travetto/model';
import { Text } from '@travetto/schema';
import { AppError } from '@travetto/base';
import { isExpirySupported, isStorageSupported } from '@travetto/model/src/internal/service/common';
import { EnvUtil } from '@travetto/boot';
import { ValueAccessor } from '@travetto/rest/src/internal/accessor';

import { SessionProvider } from '../provider/types';
import { Session } from '../types';
import { SessionConfig } from '../config';

export const SessionModelSym = Symbol.for('@trv:rest-session/model');

@Model({ autoCreate: false })
export class SessionEntry {
  id: string;
  @Text()
  data: string;
  @ExpiresAt()
  expiresAt?: Date;
  issuedAt: Date;
  maxAge?: number;
}

/**
 * Uses request for maintaining the session coherency with the user.
 */
@Injectable()
export class ModelSessionProvider implements SessionProvider {

  @Inject()
  config: SessionConfig;

  /**
   * Cache for storing the session
   */
  @Inject(SessionModelSym)
  modelService: ModelCrudSupport;

  accessor: ValueAccessor;

  /**
   * Initialize service if none defined
   */
  async postConstruct() {
    if (!isExpirySupported(this.modelService)) {
      throw new AppError(`Model service must provide expiry support, ${this.modelService.constructor.name} does not.`);
    }
    if (isStorageSupported(this.modelService)) {
      if (!EnvUtil.isReadonly()) {
        await this.modelService.createModel?.(SessionEntry);
      }
    }
    this.accessor = new ValueAccessor(this.config.keyName, this.config.transport);
  }

  async delete(req: Request, res: Response, id: string) {
    await this.modelService.delete(SessionEntry, id).then(() => true, () => false);
  }

  async encode(req: Request, res: Response, session: Session | null): Promise<void> {
    if (session) {
      // Store update of session
      await this.modelService.upsert(SessionEntry, SessionEntry.from({
        ...session,
        data: Buffer.from(JSON.stringify(session.data)).toString('base64')
      }));

      // Send updated info only if expiry changed
      if (session.isTimeChanged()) {
        this.accessor.writeValue(res, session.id, { expires: session.expiresAt });
      }
    } else {
      this.accessor.writeValue(res, null, { expires: new Date() });
    }
    return;
  }

  async decode(req: Request): Promise<Session | undefined> {
    const id = this.accessor.readValue(req);
    if (id) {
      const record = await this.modelService.get(SessionEntry, id).catch(() => { });

      if (record) {
        return new Session({
          ...record,
          data: JSON.parse(Buffer.from(record.data, 'base64').toString('utf8'))
        });
      }
    }
  }
}
```
