<!-- This file was generated by the framweork and should not be modified directly -->
<!-- Please modify https://github.com/travetto/travetto/tree/master/module/cache/DOCS.js and execute "npm run docs" to rebuild -->
# Caching
## Caching functionality with decorators for declarative use.

**Install: @travetto/cache**
```bash
npm install @travetto/cache
```

Provides a foundational structure for integrating caching at the method level.  This allows for easy extension with a variety of providers, and is usable with or without [Dependency Injection](https://github.com/travetto/travetto/tree/master/module/di#readme "Dependency registration/management and injection support.").  The code aims to handle use cases surrounding common/basic usage.

## Decorators
The caching framework provides method decorators that enables simple use cases.  One of the requirements to use the caching decorators is that the method arguments, and return values need to be serializable into JSON.  Any other data types are not currently supported and would require either manual usage of the caching services directly, or specification of serialization/deserialization routines in the cache config.

Additionally, to use the decorators you will need to have a [CacheSource](https://github.com/travetto/travetto/tree/master/module/cache/src/source/core.ts#L10) object accessible on the class instance. This can be dependency injected, or manually constructed. The decorators will detect the field at time of method execution, which decouples construction of your class from the cache construction.

[@Cache](https://github.com/travetto/travetto/tree/master/module/cache/src/decorator.ts#L16) is a decorator that will cache all successful results, keyed by a computation based on the method arguments.  Given the desire for supporting remote caches (e.g. [redis](https://redis.io), [memcached](https://memcached.org)), only asynchronous methods are supported. Though if you do have a cache source that is synchronous, you can use it directly to support synchronous workloads.

**Code: Using decorators to cache expensive async call**
```typescript
import { MemoryCacheSource } from '@travetto/cache/src/source/memory';
import { Cache } from '@travetto/cache/src/decorator';

async function request(url: string) {
  let value;
  // ...fetch content
  return value;
}

export class Worker {

  myCache = new MemoryCacheSource();

  @Cache('myCache', { maxAge: 1000 })
  async calculateExpensiveResult(expression: string) {
    const value = await request(`https://google.com?q=${expression}`);
    return value;
  }
}
```

### [@Cache](https://github.com/travetto/travetto/tree/master/module/cache/src/decorator.ts#L16)

The [@Cache](https://github.com/travetto/travetto/tree/master/module/cache/src/decorator.ts#L16) decorator supports configurations on:

   
   *  `name` the field name of the current class which points to the desired cache source.
   *  `config` the additional/optional config options, on a per invocation basis    
      *  `keySpace` the key space within the cache.  Defaults to class name plus method name.
      *  `key` the function  will use the inputs to determine the cache key, defaults to all params `JSON.stringify`ied
      *  `params` the function used to determine the inputs for computing the cache key.  This is an easier place to start to define what parameters are important in ,caching. This defaults to all inputs.
      *  `maxAge` the number of milliseconds will hold the value before considering the cache entry to be invalid.  By default values will live infinitely.
      *  `extendOnAccess` determines if the cache timeout should be extended on access.  This only applies to cache values that have specified a `maxAge`.
      *  `serialize` the function to execute before storing a cacheable value.  This allows for any custom data modification needed to persist as a string properly.
      *  `reinstate` the function to execute on return of a cached value.  This allows for any necessary operations to conform to expected output (e.g. re-establishing class instances, etc.).  This method should not be used often, as the return values of the methods should naturally serialize to/from `JSON` and the values should be usable either way.

### [@EvictCache](https://github.com/travetto/travetto/tree/master/module/cache/src/decorator.ts#L27)

Additionally, there is support for planned eviction via the [@EvictCache](https://github.com/travetto/travetto/tree/master/module/cache/src/decorator.ts#L27) decorator.  On successful execution of a method with this decorator, the matching keySpace/key value will be evicted from the cache.  This requires coordination between multiple methods, to use the same `keySpace` and `key` to compute the expected key.

**Code: Using decorators to cache/evict user access**
```typescript
import { MemoryCacheSource } from '@travetto/cache/src/source/memory';
import { Cache, EvictCache } from '@travetto/cache/src/decorator';

class User { }

export class UserService {

  myCache = new MemoryCacheSource();
  database: any;

  @Cache('myCache', { keySpace: 'user.id' })
  async getUser(id: string) {
    return this.database.lookupUser(id);
  }

  @EvictCache('myCache', { keySpace: 'user.id', params: user => [user.id] })
  async updateUser(user: User) {
    this.database.updateUser(user);
  }

  @EvictCache('myCache', { keySpace: 'user.id' })
  async deleteUser(userId: string) {
    this.database.deleteUser(userId);
  }
}
```

## Building a Custom Source

The module comes with a [MemoryCacheSource](https://github.com/travetto/travetto/tree/master/module/cache/src/source/memory.ts#L8) and a [FileCacheSource](https://github.com/travetto/travetto/tree/master/module/cache/src/source/file.ts#L22). The module also has extension for a [redis](https://redis.io) source and [Data Modeling](https://github.com/travetto/travetto/tree/master/module/model#readme "Datastore abstraction for CRUD operations with advanced query support.")-backed source.

**Code: Cache Source Structure**
```typescript
import { CacheEntry, CacheConfig, ICacheSource } from '../types';
import { CacheSourceUtil } from './util';
import { CacheError } from './error';
type OrProm<T> = T | Promise<T>;
/**
 * Cache source
 */
export abstract class CacheSource<T extends CacheEntry = CacheEntry> implements ICacheSource<T> {
  abstract get(key: string): OrProm<T | undefined>;
  abstract has(key: string): OrProm<boolean>;
  abstract set(key: string, entry: T): OrProm<T>;
  abstract isExpired(key: string): OrProm<boolean>;
  abstract touch(key: string, expiresAt: number): OrProm<boolean>;
  abstract delete(key: string): OrProm<boolean>;
  abstract keys(): OrProm<Iterable<string>>;
  clear?(): OrProm<void> | void;
  async getAndCheckAge(config: CacheConfig, key: string) ;
  setWithAge(config: CacheConfig, entry: Partial<T> & { data: any, key: string }) ;
  async getOptional(config: CacheConfig, key: string) ;
}
```

For the source, all abstract methods must be implemented. All of the more complex logic is implemented in other methods within the base [CacheSource](https://github.com/travetto/travetto/tree/master/module/cache/src/source/core.ts#L10).   The structure follows that of the javascript `Map` class for consistency. All that is needed is basic input/output support:

   
   *  `get(key: string)` - Fetch entry from source, and return in the structure of an entry, ready to go
   *  `has(key: string)` - Indicates whether or not the key exists
   *  `set(key: string, entry: CacheEntry)` - Sources entry, given `key`.
   *  `delete (key: string)` - Removes entry by key
   *  `isExpired(key: string)` - Determines if entry is expired
   *  `touch(key: string, expiresAt: number)` - Updates expiry information to date provided
   *  `keys()` - Returns list of all keys in the source

Additionally, for setting/getting the burden is on the source author to properly serialize/deserialize as needed.  This is a low level detail and cannot be accounted for in a generic way.

**Code: MemoryCacheSource**
```typescript
import { CullableCacheSource } from './cullable';
import { CacheEntry } from '../types';
import { CacheSourceUtil } from './util';

/**
 * A cache source backed by `Map`
 */
export class MemoryCacheSource<T extends CacheEntry = CacheEntry> extends CullableCacheSource<T> {

  store = new Map<string, { expiresAt?: number, entry: string }>();

  clear() {
    this.store.clear();
  }

  has(key: string): boolean {
    return this.store.has(key);
  }

  get(key: string): T | undefined {
    const entry = this.store.get(key);
    if (entry) {
      return {
        ...CacheSourceUtil.readAsSafeJSON(entry.entry),
        expiresAt: entry.expiresAt
      };
    }
  }

  async set(key: string, entry: T): Promise<any> {
    this.cull();

    const cloned = CacheSourceUtil.storeAsSafeJSON(entry);

    this.store.set(key, { entry: cloned, expiresAt: entry.expiresAt });

    return CacheSourceUtil.readAsSafeJSON(cloned);
  }

  touch(key: string, expiresAt: number): boolean {
    this.store.get(key)!.expiresAt = expiresAt;
    return true;
  }

  delete(key: string): boolean {
    return this.store.delete(key);
  }

  keys() {
    return this.store.keys();
  }

  isExpired(key: string) {
    const entry = this.store.get(key);
    if (entry) {
      return !!entry.expiresAt && entry.expiresAt! < Date.now();
    }
    return false;
  }
}
```

The memory source is simple but illustrates the structure well.
