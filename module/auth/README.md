<!-- This file was generated by @travetto/doc and should not be modified directly -->
<!-- Please modify https://github.com/travetto/travetto/tree/main/module/auth/doc.ts and execute "npx trv doc" to rebuild -->
# Authentication
## Authentication scaffolding for the travetto framework

**Install: @travetto/auth**
```bash
npm install @travetto/auth
```

This module provides the high-level backdrop for managing security principals.  The goal of this module is to be a centralized location for various security frameworks to plug into.  The primary contributions are:

   
   *  Standard Types
   *  Authentication Contract
   *  Authorization Contract
   *  Common security-related utilities for    
      *  Checking permissions
      *  Generating passwords

## Standard Types
The module's goal is to be as flexible as possible.  To that end, the primary contract that this module defines, is that of the [Principal Structure](https://github.com/travetto/travetto/tree/main/module/auth/src/types/principal.ts#L8).

**Code: Principal Structure**
```typescript
export interface Principal<D = { [key: string]: any }> {
  /**
   * Primary identifier for a user
   */
  id: string;
  /**
   * Date of expiration
   */
  expiresAt?: Date;
  /**
   * Date of issuance
   */
  issuedAt?: Date;
  /**
   * Max age in seconds a principal is valid
   */
  maxAge?: number;
  /**
   * The source of the issuance
   */
  issuer?: string;
  /**
   * Supplemental details
   */
  details: D;
  /**
   * List of all provided permissions
   */
  permissions?: string[];
}
```

As referenced above, a [Principal Structure](https://github.com/travetto/travetto/tree/main/module/auth/src/types/principal.ts#L8) is defined as a user with respect to a security context. This can be information the application knows about the user (authorized) or what a separate service may know about a user (3rd-party authentication).

## Authentication

**Code: Authenticator**
```typescript
export interface Authenticator<T = unknown, P extends Principal = Principal, C = unknown> {
  /**
   * Verify the payload, verifying the payload is correctly identified.
   * @returns Valid principal if authenticated
   * @returns undefined if authentication is valid, but incomplete (multi-step)
   * @throws AppError if authentication fails
   */
  authenticate(payload: T, ctx?: C): Promise<P | undefined> | P | undefined;
}
```

The [Authenticator](https://github.com/travetto/travetto/tree/main/module/auth/src/types/authenticator.ts#L8) only requires one method to be defined, and that is `authenticate`. This method receives a generic payload, and a supplemental context as an input. The interface is responsible for converting that to an authenticated principal.

### Example
The [JWT](https://github.com/travetto/travetto/tree/main/module/jwt#readme "JSON Web Token implementation") module is a good example of an authenticator. This is a common use case for simple internal auth.

## Authorization

**Code: Authorizer**
```typescript
export interface Authorizer<P extends Principal = Principal> {
  /**
   * Authorize inbound principal, verifying it's permission to access the system.
   * @param principal
   * @returns New principal that conforms to the required principal shape
   */
  authorize(principal: Principal): Promise<P> | P;
}
```

Authorizers are generally seen as a secondary step post-authentication. Authentication acts as a very basic form of authorization, assuming the principal store is owned by the application.

The [Authorizer](https://github.com/travetto/travetto/tree/main/module/auth/src/types/authorizer.ts#L8) only requires one method to be defined, and that is `authorizer`. This method receives an authenticated principal as an input, and is responsible for converting that to an authorized principal.

### Example
The [Data Modeling Support](https://github.com/travetto/travetto/tree/main/module/model#readme "Datastore abstraction for core operations.") extension is a good example of an authenticator. This is a common use case for simple internal auth.

Overall, the structure is simple, but drives home the primary use cases of the framework. The goals are:
   
   *  Be able to identify a user uniquely
   *  To have a reference to a user's set of permissions
   *  To have access to the principal

## Common Utilities
The [AuthUtil](https://github.com/travetto/travetto/tree/main/module/auth/src/util.ts#L24) provides the following functionality:

**Code: Auth util structure**
```typescript
import * as crypto from 'crypto';
import * as util from 'util';
import { AppError, Util } from '@travetto/base';
const pbkdf2 = util.promisify(crypto.pbkdf2);
type PermSet = Set<string> | ReadonlySet<string>;
type PermissionChecker = {
  all: (perms: PermSet) => boolean;
  any: (perms: PermSet) => boolean;
};
type PermissionCheckerSet = {
  includes: (perms: PermSet) => boolean;
  excludes: (perms: PermSet) => boolean;
  check: (value: PermSet) => boolean;
};
/**
 * Standard auth utilities
 */
export class AuthUtil {
  /**
   * Build a permission checker against the provided permissions
   *
   * @param perms Set of permissions to check
   * @param defaultIfEmpty If no perms passed, default to empty
   */
  /**
   * Build a permission checker off of an include, and exclude set
   *
   * @param include Which permissions to include
   * @param exclude Which permissions to exclude
   * @param matchAll Whether not all permissions should be matched
   */
  static permissionChecker(include: Iterable<string>, exclude: Iterable<string>, mode: 'all' | 'any' = 'any'): PermissionCheckerSet ;
  /**
   * Build a permission checker off of an include, and exclude set
   *
   * @param include Which permissions to include
   * @param exclude Which permissions to exclude
   * @param matchAll Whether not all permissions should be matched
   */
  static checkPermissions(permissions: Iterable<string>, include: Iterable<string>, exclude: Iterable<string>, mode: 'all' | 'any' = 'any'): void ;
  /**
   * Generate a hash for a given value
   *
   * @param value Value to hash
   * @param salt The salt value
   * @param iterations Number of iterations on hashing
   * @param keylen Length of hash
   * @param digest Digest method
   */
  static generateHash(value: string, salt: string, iterations = 25000, keylen = 256, digest = 'sha256'): Promise<string> ;
  /**
   * Generate a salted password, with the ability to validate the password
   *
   * @param password
   * @param salt Salt value, or if a number, length of salt
   * @param validator Optional function to validate your password
   */
  static async generatePassword(password: string, salt: number | string = 32): Promise<{ salt: string, hash: string }> ;
}
```

`permissionSetChecker` is probably the only functionality that needs to be explained.The function operates in a `DENY` / `ALLOW` mode.  This means that a permission check will succeed only if:

   
   *  The user is logged in     
      *  If `matchAll` is false:    
         *  The user does not have any permissions in the exclusion list
         *  The include list is empty, or the user has at least one permission in the include list.
      *  Else    
         *  The user does not have all permissions in the exclusion list
         *  The include list is empty, or the user has all permissions in the include list.
